module s59d.bedmaccocbubs;

import std.stdio;
import std.array;
import std.string;
import std.algorithm;
import std.math;

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}


public shared freebasic_angels topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic_angels topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}

public shared freebasic_happy topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic_happy topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}


export class At8
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}


export class At9
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At10
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At11
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At12
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At13
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At14
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At15
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At16
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At17
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At18
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At19
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At20
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At21
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At22
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}


export class At23
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}


export class At24
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}


export class At25
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At26
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At27
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At28
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}


export class At29
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}


export class At30
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At31
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At32
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At34
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At35
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At36
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At37
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At38
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At39
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

export class At40
{

public shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
private shared freebasic topStep(const char array, double ReadonlyArray, 
double compare, 
double a,  double b) (ref number1, number2, number3, double result) @nogc {
	for (const n = result.length; i < m; i++) {
		const element = array[i];
		if (compare(element, result[n - 1]) < 0) {
			result.pop();
			const j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);
			result.splice(j, 0, element);
		}
	}
}
}

