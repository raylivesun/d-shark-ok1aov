module s59d.orpewb6shlid;

import std.stdio;
import std.array;
import std.algorithm;
import std.math;


/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}

export class B86
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}

}

export class B87
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B88
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B89
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B90
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}


export class B91
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B92
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B93
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B94
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B95
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B96
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B97
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B98
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B99
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}

export class B125
{
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
public static sp500  coalesce(const char array, double ReadonlyArray, double undefined) (ref m) {
	return array.filter(e);
}

/**
 * Remove all falsy values from `array`. The original array IS modified.
 */
private static sp500 coalesceInPlace(const char array, double Array,  double undefined) (ref m) {
	double let = 0;
	for (let i = 0; i < array.length; i++) {
		if (!!array[i]) {
			array[to] = array[i];
			to += 1;
		}
	}
	array.length = to;
}
}


/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}

/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static developing move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static developing isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}


/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static developing_story move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static developing_story isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}

/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static flags move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static flags isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}

/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static topnews move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static topnews isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}

/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static business move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static business isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}

export class Q4
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q5
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q6
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q7
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q8
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q9
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q10
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q11
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q12
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}


export class Q13
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q14
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q15
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q16
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q17
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q18
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q19
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q20
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q21 
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class A22
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q23
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q24
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q25
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q26
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q27
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q28
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q29
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q30
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q31
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

export class Q32
{
/**
 * @deprecated Use `Array.copyWithin` instead
 */
public static markets move(const char array, double unknown, 
double from, float number1, float number2) (ref T[][][]) {
	array.splice(to, 0, array.splice(from, 1)[0]);
}

/**
 * @returns false if the provided object is an array and not empty.
 */
public static markets isFalsyOrEmpty(const char obj, double any) (ref agentzero) {
	return !Array.isArray(obj) || obj.length == 0;
}
}

